===========
Call tester
===========

This program connects to an Asterisk server and performs call tests, i.e.
it causes one channel to call another and verifies that the call worked.

There's also a small JSON server built in that reports on the results and
which can be used to trigger a test.

Configuration
=============

The configuration is a YAML file::

    logging:
      disable_existing_loggers: false
      formatters:
        std: {class: calltest.util.TimeOnlyFormatter, format: '%(asctime)s %(levelname)s:%(name)s:%(message)s'}
      handlers:
        logfile: {class: logging.FileHandler, filename: test.log, formatter: std, level: DEBUG}
        stderr: {class: logging.StreamHandler, formatter: std, level: DEBUG, stream: 'ext://sys.stderr'}
      loggers:
        asyncari: {level: INFO}
      root:
        handlers: [stderr]
        level: ERROR
      version: 1
    
    asterisk:
      app: calltest
      host: localhost
      init_timeout: 5
      port: 8088
      ssl: false

      username: asterisk # CHANGE ME
      password: asterisk # CHANGE ME

      dialplan:
        country: "49"
        city: "123" # CHANGE ME
        intl: "00"
        nat: "0"

      audio: "sound:calltest/"

    server:
      host: 127.0.0.1  # no security here: TODO
      port: 8080

    links: 
      :default:
        channel: none
        number: none
        prio: 0
      foo:
        channel: "SIP/foo/{nr}"
        number: "+49123456789"
      bar:
        channel: "SIP/bar/{nr}"
        number: "+49987654321"

    calls:
      ':default:':
        dst: null
        mode: dtmf
        test:
          repeat: 600
          retry: 300
          warn: 1
          fail: 1
          skip: false
        src: null
        timeout: 30
        audio:  # Path names for audio files.
          src_in: null
          src_out: null
          dst_in: null
          dst_out: null
        dtmf:
          len: 4  # number of digits
          may_repeat: false  # flag whether repeat decodes are accepted
                             #  does not affect the generated digits
        delay:  # values may be floats
          pre: 1  # incoming: before doing anything
          ring: 1  # incoming: after RING
          answer: 1  # in and out: after call establishment

      foobar:
        src: foo
        dst: bar
        ringtime: 0  # min time a call must be in RING state (outgoing),
                     # time between RING and answering (incoming)
        url: "" # trigger
        info: "Check that calling bar from foo works")

The ``logging`` section is described in Python's documentation.

The ``asterisk`` section describes how to connect to your Asterisk server.

``asterisk``, ``server`` and ``logging`` are default sections. In your
config you only need to add or replace the values you care about,
everything else will be defaulted in.


Links
+++++

``links`` contains the Asterisk channels that CallTest can use.

These parameters are used when originating a call on the link:

* channel: The dial string used to call out on this channel. ``{nr}`` is a
  placeholder for the destination phone number.

These parameters are used when answering a call:

* number: The number to dial, when calling this link.

The ``prio`` value is used for avoiding deadlocks when acquiring links for
bidirectional tests. If identical, the link's name is used.

The ':default:' values are applied to all other entries (unless overridden),
which saves you from changing 999 identical entries.


Calls
+++++

``calls`` contains a number of (named) tests.

* src: the source link to use, i.e. to originate the call.

* dst: the destination to use, i.e. to answer the call.

* mode: How to perform a test. See below.

* timeout: Hard limit for a call's duration. If a call exceeds this,
  it is terminated and the test fails.

* url: for answer-only modes, you need a way to cause a call. For now this
  is done by fetching the data at this URL.

The ':default:' values are applied to all other entries (unless overridden),
which saves you from changing 999 identical entries.

The ``test`` subheading contains values that are relevant for running
repeated tests in the background:

* retry, repeat: seconds to delay until repeating a call, depending on
  whether the previous attempt failed or succeeded.

* warn: number of consecutive failures when the test enters "warn" state.

* fail: number of consecutive failures when the test enters "fail" state.

* skip: if True, this test can only be triggered manually.


Modes
+++++

You can configure how CallTest processes a call.

dtmf
----

The answering channel sends a random sequence of DTMF tones. The originator
then does the same thing. The codes must match.

When ``dtmf.may_repeat`` is set, the receiver is allowed to read duplicate DTMF
tones. This flag might be necessary with in-band signalling.

``dtmf.len`` is the number of digits to test. Typically, one digit will be
repeated. The sequence is otherwise random.

audio
-----

TODO.

Audio files are played to the other side.

call
----

The answering channel will acknowledge that it's ringing, but then simply
hang up.

audio
-----

TODO.

Like DTMF, but both send a sound file instead. The sounds are recorded.
They should match, somewhat.

ring
----

Originate-only: call this number. It should be RINGING. Then hang up.

play
----

Originate-only: call this number. It should answer. Play a sound, then
hang up.

If no ``src_out`` sound is specified, simply hang up.

fail
----

TODO.

Originate-only: call this number. The call may not go through. It must be
rejected before getting to RING state, some time before ``ringtime``.

timeout
-------

TODO.

Originate-only: call this number. The call may not go through. It must be
RINGing and then be rejected between ``ringtime`` and ``timeout`` seconds
later.

wait
----

TODO.

Answer-only: wait for an incoming call, set it to RINGING, wait a few
seconds, hang up.

answer
------

TODO.

Answer-only: wait for an incoming call, answer it, optionally play a sound,
then hang up.

record
------

TODO.

Answer-only:  wait for an incoming call, answer it, optionally play a sound,
and record incoming audio until the originator hangs up.


Number format
+++++++++++++

CallTest recognizes two kinds of phone numbers: site-local extensions, and
everything else. CallTest distinguishes these by the initial '+'.

Outgoing
--------

The outgoing Asterisk channel should be able to handle both kinds directly.
If not, either drop-kick your phone provider, or write a "Local" channel
that mangles the dialled number for you. For instance, if you need to drop
the '+', use this macro::

    context mangle {
        _+! => { Dial(SIP/broken/${EXTEN:1}) }
    }

and then call ``Local/{nr}@mangle``. As another example, if you need to use
local dial strings::

    context mangle {
        _X! => Dial(SIP/broken/${EXTEN});  // pass-thru for local extensions
        _+49123! => Dial(SIP/broken/${EXTEN:6});
        _+49! => Dial(SIP/broken/0${EXTEN:3});
        _+! => Dial(SIP/broken/00${EXTEN:1});
    }

though you can probably get by with just the first and last line.

Incoming
--------

CallTest will verify that, the caller's number on an incoming call matches
the number in source link. If that number is prefixed with a '+', the
caller's number is converted to international format and needs to match
exactly. Otherwise, the source number must be at the end of the caller's.

This ensures that there's no incoming nonsense, while acknowledging that
site-local numbers often are not transmitted cleanly.

If you need Asterisk to mangle the caller's number so that it looks sane
enough for CallTest, add that to the ``calltest`` macro. For instance, to
drop a leading zero::

    macro calltest(typ) {
        SET(cid=${CALLERID(num)})
        switch(cid) {
            pattern 0.:
                set(CALLERID(num)=${cid:1});
                break;
            default:
                break;
        }
        Stasis("calltest", ${typ});
        Hangup();
        return;
    }

Asterisk configuration
++++++++++++++++++++++

Server connection
-----------------

Some parameters in the ``asterisk``section require further elucidation.

* app: 

* audio: the (base of) the "sound" URL which Asterisk will use to find your
  test's outgoing sound files. Should be ``sound:/some/absolute/path``.

Test setup
----------

Asterisk needs to know how to direct incoming calls to the tester. This is
typically done with a Stasis macro. This is for ``extensions.ael``::

    macro calltest(link,nr) {
        Stasis(calltest,${link},${nr});
        Hangup();
        return;
    }

* calltest: the ``asterisk.app`` config parameter. 

* link: the name of the link, in ``asterisk.link``.

* nr: the incoming destination phone number.

You'd call this macro from your context::

    1234 => &calltest(foo,${EXTEN});

If you want to route all incoming calls on a channel to this macro, use
something like this context::

context ext_bar {
        s => &calltest(bar,);
        i => &calltest(bar,${INVALID_EXTEN});
        _+! => &calltest(bar,${EXTEN});
        _X! => &calltest(bar,${EXTEN});
        h => Hangup();
}

Warning::

    These calls all have no spaces after the argument-separating commas.
    This is important.

Line setup
----------

PJSIP is not very forgiving. Sample config: TODO.

In lieu of voice quality checking, which this system does not yet do, you
might want to simply set your endpoints' DTMF mode to "inband". Don't use a
compressing codec when you do this. You might need to set the test's
``dtmf_may_repeat`` option. However, in-band DTMF is not particularly
reliable and may break randomly.

The random DTMF sequence only uses digits because letters are not
universally passed on, while ``#`` and ``*`` may be interpreted and thus
swallowed by intermediate systems.

